package org.apache.zookeeper;

import java.util.ArrayList;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.log4j.Logger;

/**
 * Manage watchers & handle events generated by the ClientCnxn object.
 *
 * We are implementing this as a nested class of ZooKeeper so that
 * the public methods will not be exposed as part of the ZooKeeper client
 * API.
 */
public class ZKWatchManager {
	
	public enum WATCHTYPE{DATA,EXIST,CHILD};
	
	static Logger LOG = Logger.getLogger(ZKWatchManager.class);
	
	private final EnumMap<ZKWatchManager.WATCHTYPE, Map<String, Set<Watcher>>> watches = new EnumMap<ZKWatchManager.WATCHTYPE, Map<String, Set<Watcher>>>(ZKWatchManager.WATCHTYPE.class);

    private volatile Watcher defaultWatcher;
    
    public ZKWatchManager() {
    	for(ZKWatchManager.WATCHTYPE type : WATCHTYPE.values()){
    		watches.put(type, new HashMap<String, Set<Watcher>>());
    	}
	}

	public Watcher getDefaultWatcher() {
		return defaultWatcher;
	}

	public void setDefaultWatcher(Watcher defaultWatcher) {
		this.defaultWatcher = defaultWatcher;
	}

	final private void addTo(Set<Watcher> from, Set<Watcher> to) {
        if (from != null) {
            to.addAll(from);
        }
    }
    
    public boolean hasWatches() {
    	for(ZKWatchManager.WATCHTYPE type : WATCHTYPE.values()){
    		if(!watches.get(type).isEmpty()) return true;
    	}
    	return false;
    }

    /* (non-Javadoc)
     * @see org.apache.zookeeper.ClientWatchManager#materialize(Event.KeeperState, Event.EventType, java.lang.String)
     */
    public Set<Watcher> materialize(WatchedEvent event)
    {
        Set<Watcher> result = new HashSet<Watcher>();

        String serverPath = event.getPath();
		switch (event.getType()) {
        case None:
            result.add(defaultWatcher);
            // clear the watches if auto watch reset is not enabled
            boolean clearWatches = ClientCnxn.getDisableAutoResetWatch() 
                              && event.getState() != Watcher.Event.KeeperState.SyncConnected;
        	for(ZKWatchManager.WATCHTYPE watchType : WATCHTYPE.values()){
        		Map<String, Set<Watcher>> watches = this.watches.get(watchType);
                for(Set<Watcher> ws: watches.values()) {
                    result.addAll(ws);
                    if(clearWatches){
                        synchronized(watches) {
                            watches.clear();
                        }
                    }
                }	
        	}

            return result;
        case NodeDataChanged:
        case NodeCreated:
            synchronized (watches.get(WATCHTYPE.DATA)) {
                addTo(watches.get(WATCHTYPE.DATA).remove(serverPath ), result);
            }
            synchronized (watches.get(WATCHTYPE.EXIST)) {
                addTo(watches.get(WATCHTYPE.EXIST).remove(serverPath), result);
            }
            break;
        case NodeChildrenChanged:
            synchronized (watches.get(WATCHTYPE.CHILD)) {
                addTo(watches.get(WATCHTYPE.CHILD).remove(serverPath), result);
            }
            break;
        case NodeDeleted:
            synchronized (watches.get(WATCHTYPE.DATA)) {
                addTo(watches.get(WATCHTYPE.DATA).remove(serverPath), result);
            }
            // XXX This shouldn't be needed, but just in case
            synchronized (watches.get(WATCHTYPE.EXIST)) {
                Set<Watcher> list = watches.get(WATCHTYPE.EXIST).remove(serverPath);
                if (list != null) {
                    addTo(list, result);
                    LOG.warn("We are triggering an exists watch for delete! Shouldn't happen!");
                }
            }
            synchronized (watches.get(WATCHTYPE.CHILD)) {
                addTo(watches.get(WATCHTYPE.CHILD).remove(serverPath), result);
            }
            break;
        default:
            String msg = "Unhandled watch event type " + event.getType()
                + " with state " + event.getState() + " on path " + serverPath;
            LOG.error(msg);
            throw new RuntimeException(msg);
        }

        return result;
    }

	public List<String> getWatchesKeys(ZKWatchManager.WATCHTYPE type) {
		List<String> rc = new ArrayList<String>(watches.get(type).keySet());
        return rc;
	}

	public Map<String, Set<Watcher>> getWatches( ZKWatchManager.WATCHTYPE type) {
		return watches.get(type);
	}
}